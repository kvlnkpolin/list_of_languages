# Анализ алгоритмов сортировки и поиска



## Сортировка выбором (Selection Sort)
Определение алгоритма: Сортировка выбором - это алгоритм сортировки, который на каждом проходе находит минимальный элемент в неотсортированной части массива и помещает его в начало отсортированной части.

Объяснение работы алгоритма: Алгоритм сортировки выбором работает путем последовательного поиска минимального элемента в неотсортированной части массива и перемещения его в начало. Функция selectionSort принимает массив arr и его размер n, где внешний цикл for (int i = 0; i < n - 1; i++) проходит по всем элементам, а внутренний цикл for (int j = i + 1; j < n; j++) ищет минимальный элемент в оставшейся части. Когда минимальный элемент найден (индекс сохраняется в minIndex), он меняется местами с текущим элементом с помощью временной переменной temp. Функция printArray выводит элементы массива через пробел, а в main создается тестовый массив, вычисляется его размер через sizeof(arr)/sizeof(arr[0]), после чего массив выводится до и после сортировки.

O(n²) - время; O(1) - память.

Почему такая временная сложность? Она составляет O(n²) во всех случаях - лучшем, среднем и худшем. Это происходит потому, что алгоритм всегда выполняет двойной цикл: внешний цикл проходит по всем n элементам, а внутренний цикл для каждого i-го элемента проходит по оставшимся n-i элементам. Количество сравнений равно n(n-1)/2, что является квадратичной функцией. Пространственная сложность составляет O(1), так как алгоритм работает на месте и не требует дополнительной памяти.

## Сортировка обменом (Bubble Sort)
Определение алгоритма: Сортировка пузырьком - это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке.

Объяснение работы алгоритма: Алгоритм сортировки пузырьком работает путем многократного прохода по массиву и сравнения соседних элементов. Функция bubble_sort принимает массив arr, где переменная n получает длину массива через len(arr). Внешний цикл for i in range(n) может выполнить до n проходов, но содержит оптимизацию с флагом swapped. Внутренний цикл for j in range(0, n - i - 1) проходит по неотсортированной части массива и сравнивает соседние элементы arr[j] и arr[j + 1]. Если они находятся в неправильном порядке, происходит обмен значений через множественное присваивание arr[j], arr[j + 1] = arr[j + 1], arr[j], и флаг swapped устанавливается в True. Если на каком-то проходе не было ни одного обмена (флаг остался False), алгоритм завершает работу досрочно через break, так как массив уже отсортирован. Функция print_array выводит элементы через пробел с помощью " ".join(map(str, arr)), преобразуя числа в строки. В основной блок кода создается тестовый массив, выводится до и после сортировки.

O(n²) - время; О(1) - память.

Почему такая временная сложность?
Сложность O(n²) возникает, потому что алгоритм делает n проходов по массиву, и на каждом проходе выполняет до n сравнений. В худшем случае (массив отсортирован в обратном порядке) выполняется n × n = n² операций. Даже с оптимизацией, в среднем случае сложность остается квадратичной.



## Сортировка вставками (Insertion Sort)
Определение алгоритма: Сортировка вставками — это алгоритм, который строит отсортированную последовательность путем поочередной вставки каждого элемента в правильную позицию относительно уже отсортированной части.

Объяснение работы алгоритма: Алгоритм сортировки вставками работает путем последовательной вставки каждого элемента в правильную позицию в уже отсортированной части массива. Функция insertionSort принимает массив array, где переменная n получает длину массива через array.length. Цикл for (int i = 1; i < n; i++) начинается со второго элемента, так как первый элемент считается уже отсортированным. Для каждого текущего элемента key = array[i] мы сохраняем его значение и начинаем сравнение с элементами отсортированной части слева через индекс j = i - 1. В цикле while (j >= 0 && array[j] > key) мы сдвигаем все элементы, большие чем key, на одну позицию вправо с помощью array[j + 1] = array[j], уменьшая j на каждом шаге. Когда находим правильную позицию, вставляем key в массив через array[j + 1] = key. Функция printArray выводит элементы массива через пробел с помощью цикла for-each. В методе main создается тестовый массив, который выводится до и после сортировки.

O(n²) - время; О(1) - память.

Почему такая временная сложность? Сложность O(n²) возникает из-за вложенного цикла, который для каждого из n элементов в худшем случае проходит почти n сравнений. Каждый новый элемент может потребовать поиска места во всей уже отсортированной части массива. В лучшем случае (массив уже отсортирован) сложность O(n) — просто проверяем порядок. 


##  Сортировка слиянием (Merge Sort)
Определение: Сортировка слиянием - это эффективный алгоритм сортировки, использующий подход "разделяй и властвуй". Он рекурсивно разделяет массив на две половины, сортирует их отдельно, а затем объединяет в один отсортированный массив.

Обьяснение работы алгоритма: Алгоритм сортировки слиянием работает по принципу «разделяй и властвуй», рекурсивно разбивая массив на меньшие части до базового случая массива из 0 или 1 элемента, который уже считается отсортированным. Функция mergeSort проверяет базовый случай через if (arr.length <= 1), затем находит середину массива mid = arr.length / 2 и делит исходный массив на левую и правую части с помощью Arrays.copyOfRange. После рекурсивной сортировки обеих половин вызывается функция merge, которая создает результирующий массив result и использует три индекса i, j, k для сравнения элементов из левого и правого массивов, выбирая меньший элемент на каждом шаге. Когда один из массивов заканчивается, оставшиеся элементы из другого массива копируются в результат. Функция printArray выводит элементы через пробел, а в main создается тестовый массив, который выводится до и после сортировки, демонстрируя работу алгоритма.

O(n log n) - время; О(n) - память.

Почему такая временная сложность? 
Сложность O(n log n) возникает из-за разделения массива пополам на log n уровней, где на каждом уровне выполняется линейная работа O(n) по слиянию отсортированных частей. Рекурсивное деление создает дерево глубиной log n, и на каждом уровне этого дерева мы обрабатываем все n элементов при слиянии, что в совокупности дает n * log n операций. Эта сложность стабильна и не зависит от исходного порядка элементов.

## Сортировка Шелла (Shell Sort)
Определение: Сортировка Шелла - это алгоритм сортировки, который является обобщением сортировки вставками. Он сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.

Работа алгоритма: Алгоритм сортировки Шелла является улучшенной версией сортировки вставками и работает путем сравнения элементов, находящихся на определенном расстоянии друг от друга. Функция shellSort принимает вектор arr и начинает с большого расстояния gap, равного n/2, которое постепенно уменьшается в два раза на каждой итерации внешнего цикла for (int gap = n/2; gap > 0; gap /= 2). Для каждого значения gap выполняется модифицированная сортировка вставками: внутренний цикл for (int i = gap; i < n; i++) проходит по элементам, начиная с позиции gap, сохраняя текущий элемент temp = arr[i], а затем во вложенном цикле for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) происходит сравнение и сдвиг элементов, находящихся на расстоянии gap, пока не будет найдена правильная позиция для вставки temp. Функция printArray выводит элементы вектора через пробел, а в main создается тестовый массив, который выводится до и после сортировки, показывая работу этого алгоритма с постепенно уменьшающимися интервалами сравнения.

O(n log²n) - время; O(1) - память.

Почему такая временная сложность? Сложность O(n log²n) возникает, потому что алгоритм несколько раз проходит по массиву с разным шагом сравнения, и при оптимальном выборе шагов количество операций растёт медленнее чем n².



## Быстрая сортировка (Quick Sort)
Определение алгоритма: Быстрая сортировка — это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного.

Объяснение работы алгоритма: Алгоритм быстрой сортировки работает по стратегии «разделяй и властвуй», выбирая опорный элемент и перераспределяя другие элементы вокруг него. Функция partition выбирает последний элемент pivot = arr[high] в качестве опорного и использует индекс i = low - 1 для отслеживания позиции, где будут размещены элементы меньше опорного. В цикле for (int j = low; j < high; j++) происходит сравнение каждого элемента arr[j] с опорным: если элемент меньше или равен pivot, индекс i увеличивается и элементы arr[i] и arr[j] меняются местами через swap. После завершения цикла опорный элемент помещается на правильную позицию с помощью swap(arr[i + 1], arr[high]), и функция возвращает индекс опорного элемента i + 1. Функция quickSort проверяет базовый случай if (low < high), затем вызывает partition для разделения массива и рекурсивно сортирует левую и правую части относительно опорного элемента через quickSort(arr, low, pi - 1) и quickSort(arr, pi + 1, high). В main создается тестовый массив, выводится до и после сортировки, демонстрируя эффективное разделение и рекурсивную обработку частей массива. 

O(n log n) - время; О(log n) - память.

Почему такая временная сложность? 
Сложность O(n log n) в среднем, потому что алгоритм рекурсивно делит массив на примерно равные части log n раз, и на каждом уровне рекурсии обрабатывает все n элементов.
Сложность O(n²) в худшем случае, потому что при неудачных разбиениях (когда массив уже отсортирован) глубина рекурсии становится n, и на каждом шаге обрабатывается почти весь массив.


## Пирамидальная сортировка (Heap Sort)
Определение: Пирамидальная сортировка - это алгоритм сортировки, основанный на структуре данных "двоичная куча". Он использует свойства max-heap для сортировки элементов массива.

Работа алгоритма: Пирамидальная сортировка использует структуру данных "куча" для сортировки элементов. Алгоритм начинается с построения max-кучи из исходного массива в функции heapSort, где цикл for (int i = n / 2 - 1; i >= 0; i--) проходит по всем нелистовым узлам и вызывает функцию heapify для преобразования поддеревьев в valid max-кучи. Функция heapify принимает массив, его размер и индекс текущего узла, вычисляет индексы левого и правого дочерних элементов через left = 2 * i + 1 и right = 2 * i + 2, находит наибольший элемент среди корня и его потомков, и если наибольший элемент не является корнем, меняет их местами и рекурсивно вызывает себя для затронутого поддерева. После построения кучи начинается фаза извлечения элементов: в цикле for (int i = n - 1; i > 0; i--) максимальный элемент (находящийся в корне кучи) перемещается в конец массива путем обмена с последним элементом, после чего размер кучи уменьшается и вызывается heapify для восстановления свойств кучи в корневом узле. Функция printArray выводит элементы массива, а в main демонстрируется работа алгоритма на тестовом массиве, показывая преобразование массива в кучу и последующее извлечение элементов в отсортированном порядке.

O(n log n) - время; O(1) - память.

Почему такая временная сложность?Временная сложность O(n log n) возникает, из-за того, что для каждого  n элемента выполняется операция с кучей, которая занимает log n времени. Построение начальной кучи из n элементов требует n операций по log n каждая.

## Последовательный поиск (Linear Search)
Определение: Последовательный поиск - это простейший алгоритм поиска, который проверяет каждый элемент массива последовательно до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

Работа алгоритма: Алгоритм последовательного поиска работает путем проверки каждого элемента массива по порядку до тех пор, пока не будет найден искомый элемент или пока не будут проверены все элементы. Функция linear_search принимает массив arr и целевое значение target, после чего в цикле for i in range(len(arr)) последовательно перебирает все элементы массива, сравнивая каждый элемент arr[i] с искомым значением через условие if arr[i] == target. Если элемент находится, функция немедленно возвращает его индекс i, а если после проверки всех элементов совпадение не найдено, возвращается значение -1. В основном блоке кода создается тестовый массив, задается целевое значение для поиска, выполняется вызов функции поиска и выводится соответствующее сообщение в зависимости от результата: либо позиция найденного элемента, либо уведомление об его отсутствии в массиве.

O(n) - время; O(1) - память.

Почему такая временная сложность?
Сложность O(n), потому что в худшем случае алгоритм должен проверить все n элементов массива один за другим, пока не найдет искомый. Это происходит, когда нужный элемент находится в конце массива или отсутствует вовсе. В лучшем случае сложность O(1) — если элемент находится сразу в начале массива.



## Бинарный поиск (Binary Search)
Определение: Бинарный поиск - это эффективный алгоритм поиска элемента в отсортированном массиве, который многократно делит интервал поиска пополам.

Работа алгоритма: Алгоритм бинарного поиска работает только на отсортированном массиве и использует стратегию "разделяй и властвуй" для эффективного нахождения элемента. Функция binarySearch принимает отсортированный массив arr и целевое значение target, устанавливая начальные границы поиска left = 0 и right = arr.size() - 1. В цикле while (left <= right) вычисляется средний индекс mid = left + (right - left) / 2 для предотвращения переполнения, после чего средний элемент arr[mid] сравнивается с целевым значением. Если элементы равны, функция возвращает индекс mid. Если целевой элемент меньше среднего, поиск продолжается в левой половине массива через right = mid - 1, а если больше - в правой половине через left = mid + 1. Если цикл завершается без нахождения элемента, возвращается -1. В функции main демонстрируется работа алгоритма на отсортированном массиве с выводом соответствующего сообщения о результате поиска.

O(log n) - время; O(1) - память.

Почему такая временная сложность?
Сложность O(log n), потому что на каждом шаге алгоритм делит область поиска пополам, исключая из рассмотрения половину оставшихся элементов. Это позволяет находить элемент в отсортированном массиве очень быстро — даже для миллиарда элементов потребуется не более 30 итераций, так как количество элементов сокращается экспоненциально.

## Интерполирующий поиск (Interpolation Search)
Определение: Интерполирующий поиск -  это алгоритм поиска в отсортированном массиве, который использует значения элементов для предсказания позиции искомого элемента.

Работа алгоритма: Класс InterpolationSearch содержит статический метод interpolationSearch, который принимает массив arr и искомое значение x. Алгоритм устанавливает начальные границы low и high, затем в цикле while проверяет, находится ли x в текущем диапазоне. Ключевая операция - вычисление позиции pos с использованием интерполяционной формулы, где разности значений используются для предсказания местоположения элемента. Условие if-else проверяет найденный элемент и корректирует границы поиска. Метод возвращает индекс элемента или -1. 

O(log log n) - время (в среднем); O(1) - память.

Почему такая временная сложность?
Сложность O(log log n) в среднем случае, потому что алгоритм не просто делит область поиска пополам, а вычисляет вероятную позицию элемента на основе значений границ искомого элемента, что позволяет находить элемент за меньшее число шагов. Однако в худшем случае, когда распределение элементов неравномерное, сложность может деградировать до O(n), так как вычисляемая позиция может оказываться соседней с текущей, требуя последовательного просмотра всех элементов.

## Поиск Фибоначчи (Fibonacci Search)
Определение: Поиск Фибоначчи - это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения индексов сравнения. Он является разновидностью бинарного поиска.

Работа алгоритма: Алгоритм поиска Фибоначчи использует последовательность Фибоначчи для поиска в отсортированном массиве. Функция fibonacciSearch начинает с вычисления чисел Фибоначчи, находя наименьшее число fibM, превышающее размер массива. Переменная offset отслеживает начало текущего диапазона поиска. В основном цикле вычисляется индекс i через комбинацию offset и числа Фибоначчи fibMMm2. Если искомый элемент x больше arr[i], поиск смещается вправо с обновлением offset и чисел Фибоначчи. Если x меньше arr[i], поиск продолжается влевой части. При нахождении элемента возвращается его индекс, иначе -1. В main демонстрируется поиск элемента в отсортированном массиве с выводом результата.

O(log n) - время; O(1) - память.

Почему такая временная сложность? 
Сложность O(log n), потому что этот поиск работает так же быстро, как обычный бинарный поиск. Он просто по-другому выбирает, где разделить массив — не посередине, а используя числа Фибоначчи. Но как и бинарный поиск, он каждый раз отбрасывает большую часть массива и быстро сужает область поиска. Даже для большого массива из миллиона элементов ему понадобится не больше 20 шагов.
