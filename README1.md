# Анализ алгоритмов сортировки и поиска



## Сортировка выбором (Selection Sort)
Определение алгоритма: Сортировка выбором - это алгоритм сортировки, который на каждом проходе находит минимальный элемент в неотсортированной части массива и помещает его в начало отсортированной части.

Объяснение работы алгоритма: Функция selectionSort объявлена с типом void, что означает отсутствие возвращаемого значения, и принимает два параметра: массив arrl! и целочисленный п, представляющий размер массива.
Внутри функции используется цикл for с инициализацией счетчика int
і = 0, условием продолжения і ‹ n
- 1 и инкрементом itt. В теле цикла объявляется переменная minIndex типа int, которая инициализируется
текущим значением і. Затем следует
вложенный цикл for с счетчиком int
j = і + 1, который проверяет все
последующие элементы массива.
Условная конструкция if (arrli] < arr[minIndex]) сравнивает
значения элементов массива, используя оператор индексации 1], И
при выполнении условия обновляет 
minIndex.После завершения внутреннего цикла выполняется обмен значений с использованием временной переменной temp типа int, где применяется операция присваивания = для перестановки элементов. Функция printArray также использует цикл for для итерации по элементам массива, а оператор cout с оператором вставки << выводит значения в поток вывода, разделенные пробелом. В функции main массив инициализируется списком в фигурных скобках {}, а оператор sizeof вычисляет размер массива в байтах. Вызов функций selectionSort и printArray происходит с передачей фактических параметров arr и n, при этом массив передается по указателю, что позволяет модифицировать его содержимое внутри функций.

Анализ Big O: Временная сложность алгоритма составляет O(n²) во всех случаях - лучшем, среднем и худшем. Это происходит потому, что алгоритм всегда выполняет двойной цикл: внешний цикл проходит по всем n элементам, а внутренний цикл для каждого i-го элемента проходит по оставшимся n-i элементам. Количество сравнений равно n(n-1)/2, что является квадратичной функцией. Пространственная сложность составляет O(1), так как алгоритм работает на месте и не требует дополнительной памяти.





## Сортировка обменом (Bubble Sort)
Определение алгоритма: Сортировка пузырьком - это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке.

Объяснение работы алгоритма: Алгоритм работает путем многократного прохода по массиву. На каждом проходе он сравнивает элементы и меняет их местами, если они расположены в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован. На каждом последующем проходе самый большой элемент "всплывает" в конец массива, отсюда и название алгоритма.

Анализ Big O: Временная сложность в худшем и среднем случае составляет O(n²), так как алгоритм использует два вложенных цикла. В лучшем случае (когда массив уже отсортирован) сложность может быть O(n) при использовании оптимизации с флагом. Пространственная сложность составляет O(1), поскольку алгоритм работает на месте.



## Сортировка вставками (Insertion Sort)
Определение алгоритма: Сортировка вставками — это алгоритм, который строит отсортированную последовательность путем поочередной вставки каждого элемента в правильную позицию относительно уже отсортированной части.

Объяснение работы алгоритма: Алгоритм делит массив на две части: отсортированную левую часть и неотсортированную правую часть. На каждом шаге алгоритм берет первый элемент из неотсортированной части и вставляет его в правильную позицию в отсортированной части, сдвигая элементы при необходимости. Этот процесс аналогичен тому, как люди сортируют карты в руке — мы держим отсортированные карты в одной части и по одной вставляем новые карты в правильные позиции. Алгоритм эффективен для небольших массивов и почти отсортированных данных.

Анализ с точки зрения Big O: В худшем случае (массив отсортирован в обратном порядке) временная сложность составляет O(n²), так как каждый новый элемент потребует сравнения со всеми элементами отсортированной части. В лучшем случае (массив уже отсортирован) сложность составляет O(n), так как каждый элемент будет сразу на своем месте. Средняя временная сложность O(n²). Пространственная сложность O(1), так как алгоритм работает на месте.


##  Сортировка слиянием (Merge Sort)
Определение: Сортировка слиянием - это эффективный алгоритм сортировки, использующий подход "разделяй и властвуй". Он рекурсивно разделяет массив на две половины, сортирует их отдельно, а затем объединяет в один отсортированный массив.

Работа алгоритма: Алгоритм работает по принципу разделения массива на все более мелкие части до тех пор, пока не останутся массивы из одного элемента (которые считаются отсортированными). Затем алгоритм начинает объединять эти маленькие массивы в большие отсортированные массивы, сравнивая элементы из двух массивов и выбирая меньший из них. Этот процесс продолжается до тех пор, пока не будет получен один полностью отсортированный массив.

Анализ Big O: Временная сложность алгоритма составляет O(n log n) во всех случаях (худшем, среднем и лучшем). Это связано с тем, что массив делится пополам log n раз, а на каждом уровне объединения выполняется O(n) операций. Пространственная сложность составляет O(n), так как алгоритм требует дополнительной памяти для хранения временных массивов во время процесса слияния.


## Сортировка Шелла (Shell Sort)
Определение: Сортировка Шелла - это алгоритм сортировки, который является обобщением сортировки вставками. Он сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.

Работа алгоритма: Алгоритм начинает с сортировки элементов, отстоящих далеко друг от друга, используя большой шаг (gap). Затем он уменьшает шаг и снова сортирует элементы. Процесс повторяется с все меньшими шагами, пока шаг не станет равным 1, и не будет выполнена окончательная сортировка вставками. Это позволяет элементам быстрее занимать свои правильные позиции.

Анализ Big O: Временная сложность зависит от выбранной последовательности шагов. В худшем случае она может достигать O(n²), но для хороших последовательностей составляет около O(n log² n). Пространственная сложность составляет O(1), так как алгоритм работает на месте.



## Быстрая сортировка (Quick Sort)
Определение алгоритма: Быстрая сортировка — это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного.

Объяснение работы алгоритма: Алгоритм работает рекурсивно, выбирая опорный элемент (pivot) и перераспределяя другие элементы вокруг него таким образом, что все элементы меньшие опорного оказываются слева от него, а все большие — справа. Затем алгоритм рекурсивно применяется к двум полученным подмассивам. Ключевым моментом является процедура разделения (partition), которая эффективно переупорядочивает элементы. Выбор опорного элемента может существенно влиять на производительность алгоритма. В среднем случае быстрая сортировка является одним из самых быстрых алгоритмов сортировки.

Анализ с точки зрения Big O: В худшем случае (когда опорный элемент всегда минимальный или максимальный) временная сложность составляет O(n²). Однако в среднем случае сложность составляет O(n log n), что делает алгоритм очень эффективным. Лучший случай также O(n log n). Пространственная сложность в среднем O(log n) из-за рекурсивных вызовов, в худшем случае O(n).


## Пирамидальная сортировка (Heap Sort)
Определение: Пирамидальная сортировка - это алгоритм сортировки, основанный на структуре данных "двоичная куча". Он использует свойства max-heap для сортировки элементов массива.

Работа алгоритма: Алгоритм сначала строит max-heap из входного массива, где наибольший элемент находится в корне. Затем он меняет корневой элемент (максимальный) с последним элементом массива и уменьшает размер кучи на 1. После этого алгоритм восстанавливает свойство max-heap для уменьшенной кучи и повторяет процесс до тех пор, пока вся куча не будет отсортирована.


## Последовательный поиск (Linear Search)
Определение: Последовательный поиск - это простейший алгоритм поиска, который проверяет каждый элемент массива последовательно до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

Работа алгоритма: Алгоритм начинает с первого элемента массива и последовательно сравнивает каждый элемент с искомым значением. Если элемент найден, возвращается его индекс. Если алгоритм доходит до конца массива и не находит элемент, возвращается специальное значение (обычно -1), указывающее на отсутствие элемента.

Анализ Big O: Временная сложность в худшем случае составляет O(n), когда элемент находится в конце массива или отсутствует. В лучшем случае сложность составляет O(1), когда элемент находится в начале массива. Средняя сложность также O(n). Пространственная сложность составляет O(1).




## Бинарный поиск (Binary Search)
Определение: Бинарный поиск - это эффективный алгоритм поиска элемента в отсортированном массиве, который многократно делит интервал поиска пополам.

Работа алгоритма: Алгоритм начинает поиск с определения среднего элемента массива. Если средний элемент равен целевому значению, поиск завершается. Если целевое значение меньше среднего элемента, поиск продолжается в левой половине массива. Если целевое значение больше среднего элемента, поиск продолжается в правой половине. Этот процесс повторяется до тех пор, пока целевой элемент не будет найден или пока интервал поиска не станет пустым.

Анализ Big O: Временная сложность алгоритма составляет O(log n), где n - количество элементов в массиве. Это связано с тем, что на каждом шаге алгоритма размер интервала поиска уменьшается вдвое. Пространственная сложность составляет O(1) для итеративной реализации и O(log n) для рекурсивной реализации из-за использования стека вызовов.
Анализ Big O: Временная сложность алгоритма составляет O(n log n) во всех случаях. Построение кучи занимает O(n) времени, а каждый из n извлечений максимального элемента требует O(log n) времени. Пространственная сложность составляет O(1), так как алгоритм работает на месте.


## Интерполирующий поиск (Interpolation Search)
Определение: Интерполирующий поиск - это алгоритм поиска в отсортированном массиве, который использует значения элементов для оценки позиции искомого элемента. Он основан на принципе интерполяции.

Работа алгоритма: Алгоритм вычисляет вероятную позицию искомого элемента на основе его значения и значений на концах текущего интервала поиска. Если вычисленная позиция содержит искомый элемент, поиск завершается. Если элемент меньше найденного, поиск продолжается в левой части, если больше - в правой. Этот подход позволяет быстрее находить элемент в равномерно распределенных данных.

Анализ Big O: В лучшем случае временная сложность составляет O(log log n) для равномерно распределенных данных. В худшем случае (когда данные распределены неравномерно) сложность может деградировать до O(n). Пространственная сложность составляет O(1) для итеративной реализации.


## Поиск Фибоначчи (Fibonacci Search)
Определение: Поиск Фибоначчи - это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения индексов сравнения. Он является разновидностью бинарного поиска.

Работа алгоритма: Алгоритм использует числа Фибоначчи для определения позиций, в которых следует сравнивать элементы. Он находит наименьшее число Фибоначчи, большее или равное размеру массива, затем использует предыдущие два числа Фибоначчи для определения позиций сравнения. В зависимости от результата сравнения алгоритм сужает область поиска и повторяет процесс.

Анализ Big O: Временная сложность алгоритма составляет O(log n), что аналогично бинарному поиску. Однако поиск Фибоначчи может быть более эффективным на некоторых типах данных из-за особенностей распределения сравнений. Пространственная сложность составляет O(1).
