# Анализ алгоритмов сортировки и поиска



## Сортировка выбором (Selection Sort)
Определение алгоритма: Сортировка выбором - это алгоритм сортировки, который на каждом проходе находит минимальный элемент в неотсортированной части массива и помещает его в начало отсортированной части.

Объяснение работы алгоритма: Алгоритм сортировки выбором работает путем последовательного поиска минимального элемента в неотсортированной части массива и перемещения его в начало. Функция selectionSort принимает массив arr и его размер n, где внешний цикл for (int i = 0; i < n - 1; i++) проходит по всем элементам, а внутренний цикл for (int j = i + 1; j < n; j++) ищет минимальный элемент в оставшейся части. Когда минимальный элемент найден (индекс сохраняется в minIndex), он меняется местами с текущим элементом с помощью временной переменной temp. Функция printArray выводит элементы массива через пробел, а в main создается тестовый массив, вычисляется его размер через sizeof(arr)/sizeof(arr[0]), после чего массив выводится до и после сортировки.

Анализ Big O: Временная сложность алгоритма составляет O(n²) во всех случаях - лучшем, среднем и худшем. Это происходит потому, что алгоритм всегда выполняет двойной цикл: внешний цикл проходит по всем n элементам, а внутренний цикл для каждого i-го элемента проходит по оставшимся n-i элементам. Количество сравнений равно n(n-1)/2, что является квадратичной функцией. Пространственная сложность составляет O(1), так как алгоритм работает на месте и не требует дополнительной памяти.

## Сортировка обменом (Bubble Sort)
Определение алгоритма: Сортировка пузырьком - это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке.

Объяснение работы алгоритма: Алгоритм сортировки пузырьком работает путем многократного прохода по массиву и сравнения соседних элементов. Функция bubble_sort принимает массив arr, где переменная n получает длину массива через len(arr). Внешний цикл for i in range(n) может выполнить до n проходов, но содержит оптимизацию с флагом swapped. Внутренний цикл for j in range(0, n - i - 1) проходит по неотсортированной части массива и сравнивает соседние элементы arr[j] и arr[j + 1]. Если они находятся в неправильном порядке, происходит обмен значений через множественное присваивание arr[j], arr[j + 1] = arr[j + 1], arr[j], и флаг swapped устанавливается в True. Если на каком-то проходе не было ни одного обмена (флаг остался False), алгоритм завершает работу досрочно через break, так как массив уже отсортирован. Функция print_array выводит элементы через пробел с помощью " ".join(map(str, arr)), преобразуя числа в строки. В основной блок кода создается тестовый массив, выводится до и после сортировки.

O(n²) - время; О(1) - память.

Анализ Big O: Временная сложность O(n²) возникает, потому что алгоритм делает n проходов по массиву, и на каждом проходе выполняет до n сравнений. В худшем случае (массив отсортирован в обратном порядке) выполняется n × n = n² операций. Даже с оптимизацией, в среднем случае сложность остается квадратичной.



## Сортировка вставками (Insertion Sort)
Определение алгоритма: Сортировка вставками — это алгоритм, который строит отсортированную последовательность путем поочередной вставки каждого элемента в правильную позицию относительно уже отсортированной части.

Объяснение работы алгоритма: Алгоритм сортировки вставками работает путем последовательной вставки каждого элемента в правильную позицию в уже отсортированной части массива. Функция insertionSort принимает массив array, где переменная n получает длину массива через array.length. Цикл for (int i = 1; i < n; i++) начинается со второго элемента, так как первый элемент считается уже отсортированным. Для каждого текущего элемента key = array[i] мы сохраняем его значение и начинаем сравнение с элементами отсортированной части слева через индекс j = i - 1. В цикле while (j >= 0 && array[j] > key) мы сдвигаем все элементы, большие чем key, на одну позицию вправо с помощью array[j + 1] = array[j], уменьшая j на каждом шаге. Когда находим правильную позицию, вставляем key в массив через array[j + 1] = key. Функция printArray выводит элементы массива через пробел с помощью цикла for-each. В методе main создается тестовый массив, который выводится до и после сортировки.

O(n²) - время; О(1) - память.

Анализ с точки зрения Big O: Для каждого нового элемента мы можем сдвигать все предыдущие элементы. В худшем случае (обратно отсортированный массив) для i-го элемента нужно сделать i сдвигов. Сумма 1 + 2 + 3 + ... + n = n(n+1)/2 ≈ n².


##  Сортировка слиянием (Merge Sort)
Определение: Сортировка слиянием - это эффективный алгоритм сортировки, использующий подход "разделяй и властвуй". Он рекурсивно разделяет массив на две половины, сортирует их отдельно, а затем объединяет в один отсортированный массив.

Обьяснение работы алгоритма: Алгоритм сортировки слиянием работает по принципу «разделяй и властвуй», рекурсивно разбивая массив на меньшие части до базового случая массива из 0 или 1 элемента, который уже считается отсортированным. Функция mergeSort проверяет базовый случай через if (arr.length <= 1), затем находит середину массива mid = arr.length / 2 и делит исходный массив на левую и правую части с помощью Arrays.copyOfRange. После рекурсивной сортировки обеих половин вызывается функция merge, которая создает результирующий массив result и использует три индекса i, j, k для сравнения элементов из левого и правого массивов, выбирая меньший элемент на каждом шаге. Когда один из массивов заканчивается, оставшиеся элементы из другого массива копируются в результат. Функция printArray выводит элементы через пробел, а в main создается тестовый массив, который выводится до и после сортировки, демонстрируя работу алгоритма.

O(n log n) - время; О(n) - память.

Анализ Big O: Массив делится пополам log₂n раз (глубина рекурсии). На каждом уровне деления выполняется O(n) операций слияния. Умножаем глубину на работу на каждом уровне: log n × n = n log n.


## Сортировка Шелла (Shell Sort)
Определение: Сортировка Шелла - это алгоритм сортировки, который является обобщением сортировки вставками. Он сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.

Работа алгоритма: Алгоритм сортировки Шелла является улучшенной версией сортировки вставками и работает путем сравнения элементов, находящихся на определенном расстоянии друг от друга. Функция shellSort принимает вектор arr и начинает с большого расстояния gap, равного n/2, которое постепенно уменьшается в два раза на каждой итерации внешнего цикла for (int gap = n/2; gap > 0; gap /= 2). Для каждого значения gap выполняется модифицированная сортировка вставками: внутренний цикл for (int i = gap; i < n; i++) проходит по элементам, начиная с позиции gap, сохраняя текущий элемент temp = arr[i], а затем во вложенном цикле for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) происходит сравнение и сдвиг элементов, находящихся на расстоянии gap, пока не будет найдена правильная позиция для вставки temp. Функция printArray выводит элементы вектора через пробел, а в main создается тестовый массив, который выводится до и после сортировки, показывая работу этого алгоритма с постепенно уменьшающимися интервалами сравнения.


Анализ Big O: 



## Быстрая сортировка (Quick Sort)
Определение алгоритма: Быстрая сортировка — это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного.

Объяснение работы алгоритма: Алгоритм быстрой сортировки работает по стратегии «разделяй и властвуй», выбирая опорный элемент и перераспределяя другие элементы вокруг него. Функция partition выбирает последний элемент pivot = arr[high] в качестве опорного и использует индекс i = low - 1 для отслеживания позиции, где будут размещены элементы меньше опорного. В цикле for (int j = low; j < high; j++) происходит сравнение каждого элемента arr[j] с опорным: если элемент меньше или равен pivot, индекс i увеличивается и элементы arr[i] и arr[j] меняются местами через swap. После завершения цикла опорный элемент помещается на правильную позицию с помощью swap(arr[i + 1], arr[high]), и функция возвращает индекс опорного элемента i + 1. Функция quickSort проверяет базовый случай if (low < high), затем вызывает partition для разделения массива и рекурсивно сортирует левую и правую части относительно опорного элемента через quickSort(arr, low, pi - 1) и quickSort(arr, pi + 1, high). В main создается тестовый массив, выводится до и после сортировки, демонстрируя эффективное разделение и рекурсивную обработку частей массива. 

O(n log n) - время; О(log n) - память.

Анализ с точки зрения Big O: В среднем случае массив делится примерно пополам на каждом шаге (log n уровней), и на каждом уровне выполняется O(n) операций разделения. Однако в худшем случае (уже отсортированный массив с плохим выбором опорного) получается O(n²), так как деление происходит на части размером 1 и n-1.


## Пирамидальная сортировка (Heap Sort)
Определение: Пирамидальная сортировка - это алгоритм сортировки, основанный на структуре данных "двоичная куча". Он использует свойства max-heap для сортировки элементов массива.

Работа алгоритма: 


## Последовательный поиск (Linear Search)
Определение: Последовательный поиск - это простейший алгоритм поиска, который проверяет каждый элемент массива последовательно до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

Работа алгоритма: Алгоритм начинает с первого элемента массива и последовательно сравнивает каждый элемент с искомым значением. Если элемент найден, возвращается его индекс. Если алгоритм доходит до конца массива и не находит элемент, возвращается специальное значение (обычно -1), указывающее на отсутствие элемента.

Анализ Big O: Временная сложность в худшем случае составляет O(n), когда элемент находится в конце массива или отсутствует. В лучшем случае сложность составляет O(1), когда элемент находится в начале массива. Средняя сложность также O(n). Пространственная сложность составляет O(1).




## Бинарный поиск (Binary Search)
Определение: Бинарный поиск - это эффективный алгоритм поиска элемента в отсортированном массиве, который многократно делит интервал поиска пополам.

Работа алгоритма: Алгоритм начинает поиск с определения среднего элемента массива. Если средний элемент равен целевому значению, поиск завершается. Если целевое значение меньше среднего элемента, поиск продолжается в левой половине массива. Если целевое значение больше среднего элемента, поиск продолжается в правой половине. Этот процесс повторяется до тех пор, пока целевой элемент не будет найден или пока интервал поиска не станет пустым.

Анализ Big O: Временная сложность алгоритма составляет O(log n), где n - количество элементов в массиве. Это связано с тем, что на каждом шаге алгоритма размер интервала поиска уменьшается вдвое. Пространственная сложность составляет O(1) для итеративной реализации и O(log n) для рекурсивной реализации из-за использования стека вызовов.
Анализ Big O: Временная сложность алгоритма составляет O(n log n) во всех случаях. Построение кучи занимает O(n) времени, а каждый из n извлечений максимального элемента требует O(log n) времени. Пространственная сложность составляет O(1), так как алгоритм работает на месте.


## Интерполирующий поиск (Interpolation Search)
Определение: Интерполирующий поиск - это алгоритм поиска в отсортированном массиве, который использует значения элементов для оценки позиции искомого элемента. Он основан на принципе интерполяции.

Работа алгоритма: Алгоритм вычисляет вероятную позицию искомого элемента на основе его значения и значений на концах текущего интервала поиска. Если вычисленная позиция содержит искомый элемент, поиск завершается. Если элемент меньше найденного, поиск продолжается в левой части, если больше - в правой. Этот подход позволяет быстрее находить элемент в равномерно распределенных данных.

Анализ Big O: В лучшем случае временная сложность составляет O(log log n) для равномерно распределенных данных. В худшем случае (когда данные распределены неравномерно) сложность может деградировать до O(n). Пространственная сложность составляет O(1) для итеративной реализации.


## Поиск Фибоначчи (Fibonacci Search)
Определение: Поиск Фибоначчи - это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения индексов сравнения. Он является разновидностью бинарного поиска.

Работа алгоритма: Алгоритм использует числа Фибоначчи для определения позиций, в которых следует сравнивать элементы. Он находит наименьшее число Фибоначчи, большее или равное размеру массива, затем использует предыдущие два числа Фибоначчи для определения позиций сравнения. В зависимости от результата сравнения алгоритм сужает область поиска и повторяет процесс.

Анализ Big O: Временная сложность алгоритма составляет O(log n), что аналогично бинарному поиску. Однако поиск Фибоначчи может быть более эффективным на некоторых типах данных из-за особенностей распределения сравнений. Пространственная сложность составляет O(1).
