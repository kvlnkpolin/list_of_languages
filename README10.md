# Тема 4.1-4.3. Алгоритмы. Приближенные и эвристические алгоритмы 

Коваленко Полина УИБО-09-24

Вариант 10: Жадный алгоритм для выбора задач (Task Selection)
Задача: реализовать жадный алгоритм для выбора максимального количества
непересекающихся задач (интервалов).
Требования:
- Каждая задача имеет время начала и завершения
- Выбрать максимальное количество задач, не пересекающихся по времени
- Вывести выбранные задачи и их количество
Входные данные:
Задачи: {(1,3), (2,5), (4,6), (5,8), (7,9), (8,10)}


## Результаты работы программы на Python

Все задачи:
(1, 3)
(2, 5)
(4, 6)
(5, 8)
(7, 9)
(8, 10)

Выбранные непересекающиеся задачи:
(1, 3)
(4, 6)
(7, 9)

Итог: выбрано 3 из 6 задач


## Объяснение алгоритма

Жадный алгоритм для выбора непересекающихся задач основан на стратегии локально оптимального выбора который приводит к глобально оптимальному решению основной принцип заключается в том чтобы на каждом шаге выбирать задачу с самым ранним временем окончания так как это оставляет максимальное количество свободного времени для последующих задач алгоритм начинает с сортировки всех задач по времени их завершения затем последовательно проходит через отсортированный список и выбирает задачу если ее время начала не раньше времени окончания последней выбранной задачи это гарантирует что выбранные задачи не будут пересекаться по времени и их количество будет максимально возможным для данного набора задач



## Объяснение работы кода

Код реализует жадный алгоритм для выбора непересекающихся задач функция greedy_task_selection принимает список задач в формате (время начала, время окончания) сначала задачи сортируются по времени окончания с помощью sorted(tasks, key=lambda x: x[1]) что позволяет выбирать задачи которые заканчиваются раньше затем алгоритм инициализирует пустой список selected_tasks для хранения выбранных задач и переменную last_end_time со значением -1 чтобы первая задача могла быть выбрана далее в цикле for проверяется каждая задача если время начала текущей задачи больше или равно last_end_time задача добавляется в список выбранных и last_end_time обновляется до времени окончания этой задачи этот процесс гарантирует что каждая новая выбранная задача не пересекается по времени с предыдущими выбранными задачами после обработки всех задач функция возвращает список выбранных непересекающихся задач


## Временная сложность

Временная сложность: O(n log n) где n - количество задач такая сложность обусловлена операцией сортировки задач по времени завершения которая требует O(n log n) операций последующий линейный проход по отсортированным задачам имеет сложность O(n) что в итоге дает общую сложность O(n log n)

Пространственная сложность: O(n) так как алгоритм требует дополнительной памяти для хранения отсортированного списка задач и результирующего списка выбранных задач


## Ответ на вопрос 10) 

Эвристические алгоритмы отличаются от приближенных наличием математически доказанных гарантий качества решения Приближенные алгоритмы всегда предоставляют оценку максимального отклонения от оптимального решения например алгоритм Кристофидеса для задачи коммивояжера гарантирует что найденный маршрут будет не более чем в 1.5 раза длиннее оптимального В то время как эвристические алгоритмы не дают таких теоретических гарантий и основаны на практических правилах которые часто но не всегда приводят к хорошим решениям

Оба типа алгоритмов используются для NP-трудных задач где поиск точного решения невозможен за разумное время Примеры приближенных алгоритмов включают алгоритмы для вершинного покрытия и задачи о рюкзаке с гарантированными границами ошибки а эвристические алгоритмы представлены генетическими алгоритмами муравьиными колониями и жадными стратегиями которые могут демонстрировать высокую эффективность на практике но без теоретических гарантий качества результата


