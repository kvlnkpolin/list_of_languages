# Рекурсивные и комбинаторные алгоритмы

Коваленко Полина УИБО-09-24

Вариант 9: Создайте рекурсивную функцию для проверки, отсортирован ли массив.

## Результаты работы программ на 3 языках

1) Python
   Проверка отсортированности массива рекурсивным методом
Введите элементы целочисленного массива через пробел
Пример ввода: 1 2 3 4 5
Ваш ввод: 1 3 5 7 9

Обработка данных
Получен массив: [1, 3, 5, 7, 9]
Размер массива: 5 элементов
Запуск рекурсивной проверки


РЕЗУЛЬТАТ ПРОВЕРКИ
Анализируемый массив: [1, 3, 5, 7, 9]
Количество элементов: 5
Состояние массива: ОТСОРТИРОВАН ПО ВОЗРАСТАНИЮ

ДЕТАЛИ АЛГОРИТМА
Алгоритм выполнил рекурсивную проверку пар элементов
Всего проверок пар: 4
Временная сложность: O(n) где n - размер массива
Пространственная сложность: O(n) из-за стека рекурсивных вызовов





3) C++
Проверка отсортированности массива рекурсивным методом
Введите элементы целочисленного массива через пробел
Пример ввода: 1 2 3 4 5
Ваш ввод: 5 2 8 1 4

Обработка данных
Получен массив: [5, 2, 8, 1, 4]
Размер массива: 5 элементов
Запуск рекурсивной проверки


РЕЗУЛЬТАТ ПРОВЕРКИ
Анализируемый массив: [5, 2, 8, 1, 4]
Количество элементов: 5
Состояние массива: НЕ ОТСОРТИРОВАН

ДЕТАЛИ АЛГОРИТМА
Алгоритм выполнил рекурсивную проверку пар элементов
Всего проверок пар: 4
Временная сложность: O(n) где n - размер массива
Пространственная сложность: O(n) из-за стека рекурсивных вызовов


3) Java
Проверка отсортированности массива рекурсивным методом
Введите элементы целочисленного массива через пробел
Пример ввода: 1 2 3 4 5
Ваш ввод: 10 20 30 40 50

Обработка данных
Получен массив: [10, 20, 30, 40, 50]
Размер массива: 5 элементов
Запуск рекурсивной проверки


РЕЗУЛЬТАТ ПРОВЕРКИ
Анализируемый массив: [10, 20, 30, 40, 50]
Количество элементов: 5
Состояние массива: ОТСОРТИРОВАН ПО ВОЗРАСТАНИЮ

ДЕТАЛИ АЛГОРИТМА
Алгоритм выполнил рекурсивную проверку пар элементов
Всего проверок пар: 4
Временная сложность: O(n) где n - размер массива
Пространственная сложность: O(n) из-за стека рекурсивных вызовов
Рекурсивная глубина: 4 вызовов


## Объяснение алгоритма


Алгоритм рекурсивной проверки отсортированности массива работает по принципу последовательного сравнения пар соседних элементов где каждый рекурсивный вызов проверяет один элемент массива и передает управление следующему вызову для проверки последующего элемента базовый случай рекурсии определяется тремя условиями которые останавливают рекурсию когда массив содержит ноль или один элемент что считается отсортированным по определению или когда достигнут последний элемент массива что означает успешную проверку всех предыдущих пар рекурсивный шаг состоит в сравнении текущего элемента с последующим элементом и если текущий элемент больше следующего это означает нарушение условия сортировки по возрастанию и функция возвращает ложь если же порядок сохраняется корректно функция рекурсивно вызывает саму себя для проверки следующей пары элементов
