# Рекурсивные и комбинаторные алгоритмы

Коваленко Полина УИБО-09-24

Вариант 9: Создайте рекурсивную функцию для проверки, отсортирован ли массив.

## Результаты работы программ на 3 языках

1) Python
Проверка отсортированности массива рекурсивным методом
Введите элементы целочисленного массива через пробел
Пример ввода: 1 2 3 4 5
Ваш ввод: 1 3 5 7 9

Обработка данных
Получен массив: [1, 3, 5, 7, 9]
Размер массива: 5 элементов
Запуск рекурсивной проверки


РЕЗУЛЬТАТ ПРОВЕРКИ
Анализируемый массив: [1, 3, 5, 7, 9]
Количество элементов: 5
Состояние массива: ОТСОРТИРОВАН ПО ВОЗРАСТАНИЮ

ДЕТАЛИ АЛГОРИТМА
Алгоритм выполнил рекурсивную проверку пар элементов
Всего проверок пар: 4
Временная сложность: O(n) где n - размер массива
Пространственная сложность: O(n) из-за стека рекурсивных вызовов





3) C++
Проверка отсортированности массива рекурсивным методом
Введите элементы целочисленного массива через пробел
Пример ввода: 1 2 3 4 5
Ваш ввод: 5 2 8 1 4

Обработка данных
Получен массив: [5, 2, 8, 1, 4]
Размер массива: 5 элементов
Запуск рекурсивной проверки


РЕЗУЛЬТАТ ПРОВЕРКИ
Анализируемый массив: [5, 2, 8, 1, 4]
Количество элементов: 5
Состояние массива: НЕ ОТСОРТИРОВАН

ДЕТАЛИ АЛГОРИТМА
Алгоритм выполнил рекурсивную проверку пар элементов
Всего проверок пар: 4
Временная сложность: O(n) где n - размер массива
Пространственная сложность: O(n) из-за стека рекурсивных вызовов


3) Java
Проверка отсортированности массива рекурсивным методом
Введите элементы целочисленного массива через пробел
Пример ввода: 1 2 3 4 5
Ваш ввод: 10 20 30 40 50

Обработка данных
Получен массив: [10, 20, 30, 40, 50]
Размер массива: 5 элементов
Запуск рекурсивной проверки


РЕЗУЛЬТАТ ПРОВЕРКИ
Анализируемый массив: [10, 20, 30, 40, 50]
Количество элементов: 5
Состояние массива: ОТСОРТИРОВАН ПО ВОЗРАСТАНИЮ

ДЕТАЛИ АЛГОРИТМА
Алгоритм выполнил рекурсивную проверку пар элементов
Всего проверок пар: 4
Временная сложность: O(n) где n - размер массива
Пространственная сложность: O(n) из-за стека рекурсивных вызовов
Рекурсивная глубина: 4 вызовов


## Объяснение алгоритма


Алгоритм рекурсивной проверки отсортированности массива работает по принципу последовательного сравнения пар соседних элементов где каждый рекурсивный вызов проверяет один элемент массива и передает управление следующему вызову для проверки последующего элемента базовый случай рекурсии определяется тремя условиями которые останавливают рекурсию когда массив содержит ноль или один элемент что считается отсортированным по определению или когда достигнут последний элемент массива что означает успешную проверку всех предыдущих пар рекурсивный шаг состоит в сравнении текущего элемента с последующим элементом и если текущий элемент больше следующего это означает нарушение условия сортировки по возрастанию и функция возвращает ложь если же порядок сохраняется корректно функция рекурсивно вызывает саму себя для проверки следующей пары элементов



## Объяснение команд и функций кода (одного из трех)

В коде функция is_sorted рекурсивно проверяет отсортированность массива путем последовательного сравнения соседних элементов начиная с указанного индекса где базовый случай рекурсии срабатывает когда массив содержит 0-1 элемент или достигнут последний элемент возвращая True а если текущий элемент превышает следующий функция немедленно возвращает False что означает нарушение сортировки иначе происходит рекурсивный вызов для следующей пары элементов основная функция main управляет всем процессом начиная с вывода инструкций для пользователя затем с помощью input().strip() получает ввод данных удаляя лишние пробелы проверяет что ввод не пустой после чего преобразует строку в список целых чисел используя map(int, user_input.split()) для разбиения строки по пробелам и преобразования каждой части в число затем выводит полученный массив и его размер вызывает рекурсивную проверку и выводит форматированные результаты с разделителями из символов "=" используя f-строки для вставки переменных и условные выражения для вывода статуса сортировки а также информацию о временной сложности O(n) и количестве фактически выполненных проверок весь код обернут в блок try-except для обработки ошибок преобразования данных и других исключений а условие if __name__ == "__main__": гарантирует что программа запустится только при прямом выполнении файла




## Анализ временной сложности
Временная сложность: O(n)

Оценка временной сложности: Алгоритм имеет линейную временную сложность O(n) где n - размер массива это означает что время выполнения алгоритма прямо пропорционально количеству элементов в массиве в худшем случае когда массив полностью отсортирован алгоритм выполняет ровно n-1 рекурсивных вызовов каждый вызов включает одно сравнение элементов и одну рекурсивную операцию в лучшем случае когда первые два элемента нарушают порядок сортировки алгоритм завершается после одной операции сравнения что соответствует O(1) однако в среднем случае для случайного массива алгоритм проверяет примерно половину элементов прежде чем обнаружить нарушение порядка что также дает линейную зависимость






## Ответ на вопрос 2) В чем разница между прямой и косвенной рекурсией?


Прямая рекурсия происходит когда функция явно вызывает саму себя внутри своего тела тогда как косвенная рекурсия возникает когда функция вызывает другую функцию которая в свою очередь вызывает исходную функцию создавая циклическую цепочку вызовов где функции взаимно зависят друг от друга и вызывают друг друга формируя рекурсивный процесс без прямого самовызова внутри одной функции


