# Аналитический отчет: кучи и хеш-таблицы

## 1. Определения структур данных

**Бинарная куча** - полное бинарное дерево в виде массива с свойством кучи (родитель меньше/больше детей). Простая структура для операций с приоритетами.

**Биномиальная куча** - набор биномиальных деревьев разного порядка. Поддерживает эффективное слияние куч.

**Куча Фибоначчи** - набор деревьев произвольной структуры. Обеспечивает амортизированно постоянное время для вставки и уменьшения ключа.

**Хеш-таблица** - структура, отображающая ключи в значения через хеш-функцию. Коллизии решаются методом цепочек или открытой адресации.

## 2. Особенности формирования куч

Все три кучи реализуют "очередь с приоритетом", но с разной эффективностью:

- **Бинарная** - простейшая единое дерево
- **Биномиальная** - набор деревьев фиксированного размера для слияния
- **Фибоначчи** - деревья произвольной формы для лучшей амортизированной сложности

## 3. Реализация на языках

### Бинарная куча

- **Python**: `import heapq; heap = []`
- **C++**: `#include <queue>; priority_queue<int> heap;`
- **Java**: `import java.util.PriorityQueue; PriorityQueue<Integer> heap;`

### Биномиальная куча
(ручная реализация). Все языки: классы с узлами и деревьями

### Куча Фибоначчи
(сложная ручная реализация). Все языки: классы с указателями/ссылками между узлами

### Хеш-таблицы

- **Python**: `hash_table = {}`
- **C++**: `#include <unordered_map>; unordered_map<string, int> map;`
- **Java**: `import java.util.HashMap; HashMap<String, Integer> map;`

## 4. Выводы

Все рассмотренные структуры данных представляют собой различные подходы к организации информации:

- **Кучи** обеспечивают эффективную работу с приоритетами, причем каждая последующая структура (бинарная → биномиальная → Фибоначчи) добавляет новые возможности ценой усложнения реализации
- **Хеш-таблицы** решают задачу быстрого доступа по ключу и демонстрируют, как разные языки предоставляют сходную функциональность через различные синтаксические конструкции

Различия в реализации между языками отражают их философию:

- **Python** предлагает максимальную простоту
- **C++** — контроль над памятью и производительностью  
- **Java** - баланс между простотой использования и строгой типизацией

При этом семантика операций остается единой, что позволяет легко переносить знания между языками программирования.
